---
title: "Chapter4: Latitude - Mass data"
author: "Elliott Schmidt"
date: "`r Sys.Date()`"
output: 
  html_document: 
    toc: true  
    toc_depth: 2
    toc_float: true
    code_folding: show
    collapse: no
    df_print: paged
    fig_caption: yes
    fig_height: 4
    fig_width: 6
    highlight: monochrome
    theme: cerulean
    latex_engine: xelatex
    
---

# Scenario 

Within this chapter developmental plasticity was explored within _Acanthochromis polyacanthus_ that were collected from two different regions (i.e., low-latitude, Cairns, and high-latitude, Mackay). Fish were held in common garden experiments at 28.5 C. Clutch data was collected along with parental morphometeric data to determine how fish from each population performed at 28.5 C, a temperature that was shown to produce similar absoluate aerobic scope performances in a previous study [link]. Once hatched offspring were placed into three different temperature treatments, 28.5, 30, and 31.5 C. After approximately 5-6 months offspring length and weight was measured, as well as CTmax and respiration during CTmax trials. 

# Load packages 

```{r load-packages-1, warning=FALSE, message=FALSE}
library(tidyverse) # data manipulation
library(ggpubr) # figure arrangement 
library(brms) # Bayesian models
library(StanHeaders)# needed to run Bayesian models
library(rstan) # needed to run Bayesian models
library(standist) # needs to be installed 
library(bayesplot) # needed for MCMC diagnostics 
library(DHARMa) # model validation 
library(ggdist) # partial plots 
library(tidybayes) # partial plots 
library(broom.mixed) # model investigation
library(emmeans) # pairwise comparisons
library(rstanarm) # pairwise comparisons - need for emmeans
```

# Set working directory 

```{r setwd-1, echo=FALSE}
knitr::opts_knit$set(root.dir="C:/Users/jc527762/OneDrive - James Cook University/PhD dissertation/Data/Chapter4_Latitude")
``` 

```{r setwd-2, echo=TRUE, eval=FALSE}
knitr::opts_knit$set(root.dir=working.dir)
```

# Import data 

```{r import-data-1, message=FALSE}
growth <- read_delim("import_files/growth_data.txt", 
    delim = "\t", escape_double = FALSE, 
    col_types = cols(NOTES = col_skip(), 
        ...16 = col_skip(), ...17 = col_skip()), 
    trim_ws = TRUE) 

clutch_data <- read_delim("import_files/clutch_data_2022_2023.txt", 
    delim = "\t", escape_double = FALSE, 
    trim_ws = TRUE) %>% 
  mutate(CLUTCH_NUMBER = as.factor(CLUTCH_NUMBER))
```

# Data manipulation 

```{r data-manipulation-1, warning=FALSE}
density <- count(growth, CLUTCH_NUMBER, TANK) |> 
  rename(DENSITY = n) |> 
  mutate(CLUTCH_NUMBER = as.factor(CLUTCH_NUMBER), 
         TANK = as.factor(TANK)) 
growth2 <- growth |> 
  mutate(CLUTCH_NUMBER = as.factor(CLUTCH_NUMBER), 
         MALE = as.factor(MALE), 
         FEMALE = as.factor(FEMALE), 
         REGION = as.factor(REGION), 
         POPULATION = as.factor(POPULATION), 
         DATE_OF_HATCH = as.Date(DATE_OF_HATCH, format = "%d/%m/%Y"), 
         DATE_SAMPLED = as.Date(DATE_SAMPLED, format = "%d/%m/%Y"), 
         DEV_TEMP = as.factor(DEV_TEMP), 
         TANK = as.factor(TANK), 
         REP = as.factor(REP), 
         LENGTH = as.numeric(LENGTH), 
         MASS = as.numeric(MASS), 
         FULTONK = (1000*MASS)/(LENGTH^3), # Adding FULTON'S K metric
         EXPERIMENT = as.factor(EXPERIMENT)) |> 
  full_join(select(clutch_data, c("CLUTCH_NUMBER",
                                   "MALE_STANDARD_LENGTH", 
                                   "MALE_MASS", 
                                   "MALE_LAT", 
                                   "MALE_LONG", 
                                   "FEMALE_STANDARD_LENGTH", 
                                   "FEMALE_MASS", 
                                   "FEMALE_LAT", 
                                   "FEMALE_LONG", 
                                   "CLUTCH_ORDER", 
                                   "DAYS_IN_TREATMENT", 
                                   "EGG_COUNT", 
                                   "HATCHING_SUCCESS")), by = "CLUTCH_NUMBER") |> 
  select(c(1:6,16:27,7:13,15,14)) |> 
  drop_na(EXPERIMENT) |>
  mutate(CLUTCH_ORDER = as.factor(CLUTCH_ORDER), 
         EXP_GROUP = as.factor(paste0(REGION,"_",DEV_TEMP))) |> 
  inner_join(density, by=c("CLUTCH_NUMBER","TANK")) |> 
  mutate(cLENGTH = scale(LENGTH, scale = FALSE)[,1], 
         cMASS = scale(MASS, scale=FALSE)[,1], 
         cFULTONK = scale(FULTONK, scale=FALSE)[,1], 
         cMALE_STANDARD_LENGTH = scale(MALE_STANDARD_LENGTH, scale=FALSE)[,1], 
         cMALE_MASS = scale(MALE_MASS, scale=FALSE)[,1], 
         cFEMALE_STANDARD_LENGTH = scale(MALE_STANDARD_LENGTH, scale=FALSE)[,1], 
         cFEMALE_MASS = scale(MALE_MASS, scale=FALSE)[,1], 
         cDENSITY = scale(DENSITY, scale=FALSE)[,1], 
         cAGE_DAYS = scale(AGE_DAYS, scale=FALSE)[,1],
         TANK = as.numeric(as.character(TANK)),
         LEVEL = as.factor(case_when(TANK >= 1 & TANK <= 199 ~ 1,
                           TANK >= 200 & TANK <= 299 ~ 2,
                           TANK >= 300 & TANK <= 399 ~ 3,
                           TRUE ~ NA_real_))) |> 
  mutate(TANK = as.factor(TANK)) |> 
  filter(MASS < 4, na.rm=TRUE, 
         FULTONK < 0.079, 
         FULTONK > 0.01, 
         DENSITY > 3)  
```

In the code above a number of variables were centered because within these metrics the value **0** is meaningless. For example you cannot have a fish length or mass of 0. Therefore, the mean was subtracted for a given variable was subtracted by every value. The y-intercept for these values will therefore reflect the mean, and the slope can be interpreted as 'y increases/decreases x amount for every 1-unit increase from the mean [INSERT METRIC]'. 


# Exploratory data analysis {.tabset}


## LENGTH VS. MASS

```{r eda-1, warning=FALSE, message=FALSE, echo=FALSE, fig.height=9, fig.width=9} 


p1 <- ggplot(growth2, aes(y=LENGTH, x=MASS)) + 
  geom_point(alpha = 0.5) + 
  geom_smooth(methos="lm", se=TRUE, fill=NA,
              formula = y~poly(x, 3, raw=TRUE), color = "red") + 
  ggtitle("All points") +
  theme_classic();p1

p2 <- ggplot(growth2, aes(y=LENGTH, x=MASS, color=REGION)) + 
  geom_point(alpha = 0.5) + 
  geom_smooth(methos="lm", se=TRUE, fill=NA,
              formula = y~poly(x, 3, raw=TRUE), color = "red") + 
  ggtitle("Latitude") +
  theme_classic() + 
  theme(legend.position = "none") 

p3 <- ggplot(growth2, aes(y=LENGTH, x=MASS, color=POPULATION)) + 
  geom_point(alpha = 0.5) + 
  geom_smooth(methos="lm", se=TRUE, fill=NA,
              formula = y~poly(x, 3, raw=TRUE), color = "red") + 
  ggtitle("Population") +
  theme_classic()  + 
  theme(legend.position = "none") 

p4 <- ggplot(growth2, aes(y=LENGTH, x=MASS, color=CLUTCH_NUMBER)) + 
  geom_point(alpha = 0.5) + 
  geom_smooth(methos="lm", se=TRUE, fill=NA,
              formula = y~poly(x, 3, raw=TRUE), color = "red") + 
  ggtitle("CLUTCH_NUMBER") +
  theme_classic() + 
  theme(legend.position = "none") 

p5 <- ggplot(growth2, aes(y=LENGTH, x=MASS, color=DEV_TEMP)) + 
  geom_point(alpha = 0.5) + 
  geom_smooth(methos="lm", se=TRUE, fill=NA,
              formula = y~poly(x, 3, raw=TRUE), color = "red") + 
  ggtitle("Developmetnal temperature") +
  theme_classic() + 
  theme(legend.position = "none")

eda1 <- ggarrange(p1,p2,p3,p4,p5, 
          ncol = 2, 
          nrow=3); eda1

```


## GROUP COMPARISONS

**NOTE:** On some of the figures ylimits have been set and therefore outliers are hidden

```{r eda-2, warning=FALSE, message=FALSE, fig.width=8, echo=FALSE}
plot.length.raw <- ggplot(growth2, aes(y=LENGTH, x=EXP_GROUP, fill=EXP_GROUP)) + 
  geom_boxplot() + 
  theme_classic() + 
  theme(axis.text.x = element_text(angle=45, vjust=0.9, hjust=1)) + 
  scale_fill_manual(values = c("salmon","firebrick1","firebrick4","skyblue","steelblue3","royalblue4")) + 
  ggtitle("LENGTH")

plot.mass.raw <- ggplot(growth2, aes(y=MASS, x=EXP_GROUP, fill=EXP_GROUP)) + 
  geom_boxplot() + 
  theme_classic() + 
  theme(axis.text.x = element_text(angle=45, vjust=0.9, hjust=1)) + 
  ylim(0,3) +
  scale_fill_manual(values = c("salmon","firebrick1","firebrick4","skyblue","steelblue3","royalblue4")) + 
  ggtitle("MASS") 

plot.k.raw <- ggplot(growth2, aes(y=FULTONK, x=EXP_GROUP, fill=EXP_GROUP)) + 
  geom_boxplot() + 
  theme_classic() + 
  theme(axis.text.x = element_text(angle=45, vjust=0.9, hjust=1)) + 
  ylim(0.02,0.05) +
  scale_fill_manual(values = c("salmon","firebrick1","firebrick4","skyblue","steelblue3","royalblue4")) + 
  ggtitle("FULTON'S K") 

ggarrange(plot.length.raw,plot.mass.raw ,plot.k.raw, 
          ncol = 3, 
          nrow=1, 
          common.legend = TRUE, 
          legend = "bottom")
``` 

## distribution

```{r eda-3, warning=FALSE, message=FALSE, echo=FALSE}
p.length <- ggplot(growth2, aes(x=LENGTH)) + 
  geom_density()+
  theme_classic() 
p.mass <- ggplot(growth2, aes(x=MASS)) + 
  geom_density()+
  theme_classic() 

ggarrange(p.length,p.mass, 
          ncol=2, 
          nrow=1)
``` 

## Parent mass and length

```{r eda-4, warning=FALSE, message=FALSE}
male.mass.plot <- ggplot(growth2, aes(x=MALE_MASS, y=MASS)) + 
  geom_point(alpha = 0.5) + 
  ggtitle("Farther vs. offspring mass") +
  theme_classic() 

female.mass.plot <- ggplot(growth2, aes(x=FEMALE_MASS, y=MASS)) + 
  geom_point(alpha = 0.5) + 
  ggtitle("Mother vs. offspring mass") +
  theme_classic()  

male.length.plot <- ggplot(growth2, aes(x=MALE_STANDARD_LENGTH, y=LENGTH)) + 
  geom_point(alpha = 0.5) + 
  ggtitle("Farther vs. offspring length") +
  theme_classic() 

female.length.plot <- ggplot(growth2, aes(x=FEMALE_STANDARD_LENGTH, y=LENGTH)) + 
  geom_point(alpha = 0.5) + 
  ggtitle("Mother vs. offspring length") +
  theme_classic()  

ggarrange(male.mass.plot, female.mass.plot, male.length.plot, female.length.plot, 
          ncol=2, 
          nrow=2)
```
# {-} 

# Fit model 

Great lets start to fit our models. There are number of variables within our data frame some of which may or may not be important. To investigate which variables are important and which are not will test different hypotheses that use different combinations of variables that are suited to answer reasonable hypotheses.  

We will start modelling the standard length of juveniles.

First we will test 3 different hypotheses as described below in more detail. All hypotheses-testing models will have **LENGTH** as the response variable as well as **DEV_TEMP** and **DENSITY** as independent variables. Note that within these models there are no random variables, we will examine random variables in later steps.  

1. The first model will test that hypotheses that juvenile length at different developmental temperatures will also be heavily influenced by the length of the parents. Therefore, this model will include both **MALE_STANDARD_LENGTH** and **FEMALE_STANDARD_LENGTH**. However, it is important to note that the length of parents will like be related to each other (i.e., _collinearity_). We will confirm this assumption with some model validation descriptive statistics. This hypothesis can be seen as out _'basic'_ model.   

```{r hypothesis-1, echo=TRUE, eval=FALSE}
cLENGTH ~ DEV_TEMP + cFEMALE_STANDARD_LENGTH + cDENSITY
```

**NOTE:** Although not displayed this model will only include **FEMALE_STANDARD_LENGTH**, when both *MALE_* and *FEMALE_* standard length are included the model is very unhappy due to the collinearity between the two variables. 

2. The second model is based around the clutch/maternal conditions. Additional variables will include **FEMALE_STANDARD_LENGTH**, **DAYS_IN_TEMPERATURE** -applies to parents, **EGG_COUNT**, and **HATCHING_SUCCESS**. The idea of this hypothesis is that offspring length may be determined by early life conditions such as the size of the mother, how long the mother was exposed to potentially stressful conditions, how wide or narrow reproductive energy was spread, as well as the potential 'health' (as indicated by hatching success) of the clutch. 

```{r hypothesis-2, echo=TRUE, eval=FALSE}
cLENGTH ~ DEV_TEMP + cFEMALE_STANDARD_LENGTH + cDENSITY + DAYS_IN_TREATMENT + EGG_COUNT + HATCHING_SUCCESS
```

3. The last model is a geographic model and will include **FEMALE_STANDARD_LENGTH**, **FEMALE_LATITUDE**, **REGION** and **DENSITY**. In all but a few cases the farther and mother are from the same reef, therefore **FEMALE_LATITUDE** should be the same as **MALE_LATITUDE**. In the event that maternal and paternal sources were from different reefs, both parents would have come from similar latitudes. **POPULATION** was not included as it caused convergence issues, potentially due to the limited sample size from different populations. 

```{r hypothesis-3, echo=TRUE, eval=FALSE}
cLENGTH ~ DEV_TEMP*REGION + cFEMALE_STANDARD_LENGTH + cDENSITY + FEMALE_LAT + REGION
```

Once these models are run will be investigate their summary statistics to determine which factors were/were not deemed to have an impact on variation explained. Further models containing combinations of variables may also be explored depending on results.

Also because we are doing Bayesian modelling we will be listing priors. Our length data is normally distributed as shown in some of the exploratory data analysis plots. We can confirm this assumption during the model validation stage as well. Out starting priors will be uninformative priors with distribution of gaussian(0,1), this may or may not change as we progress. 

## Basic model
```{r fit-model-1, cache=TRUE}
model1 <- brm(cMASS ~ DEV_TEMP*REGION + cFEMALE_MASS + cDENSITY + cAGE_DAYS + cLENGTH,
              family=gaussian(),
              data = growth2, 
              warmup = 4000, 
              iter = 10000,
              seed=123, 
              cores=2, 
              save_pars = save_pars(all=TRUE),  
              chains = 4, 
              thin = 5) 
prior_summary(model1) 
```

In this summary statistic table it tells us: 

* for the intercept, it is using a student t(flatter normal) prior with a mean of -0.1 and a standard deviation of 2.5. These values are derived from the median and median absolute deviation of the response variable 


```{r fit-model-1-3}
standist::visualize("student_t(3,-0.1,2.5)", xlim=c(-5,5))
standist::visualize("student_t(3,-0.1,2.5)", xlim=c(-5,5))
```

* for the beta coefficients, including **cDENSITY**, **cFEMALE_STANDARD_LENGTH**, **DEV_TEMP**, the default priors are inproper flat priors. 

* The prior on sigma is also a student t with a mean of **0** and a standard deviation of **0.407** 

### MCMC sampling diagnostics {.tabset} 

#### bayesplot 

```{r mcmc-diag-model1-1, fig.height=9}
mcmc_plot(model1, type='combo')
mcmc_plot(model1, type='trace') 
mcmc_plot(model1, type='dens_overlay') 
mcmc_plot(model1, type='acf_bar')
mcmc_plot(model1, type='rhat_hist')
mcmc_plot(model1, type='neff_hist') 
```

#### stan plots
```{r mcmc-diag-model1-2, fig.height=9}
stan_trace(model1$fit)
stan_ac(model1$fit) 
stan_rhat(model1$fit) 
stan_ess(model1$fit)
stan_dens(model1$fit, separate_chains = TRUE)
```

### {-}  

### Summary 

```{r summary-1}
summary(model1)
```
Within this model **cFEMALE_MASS**, and **cAGE_DAYS** have little influence on the model. 

## Maternal effects model 

```{r fit-model-2, cache=TRUE}
model.mat <- brm(cMASS ~ DEV_TEMP*REGION + cFEMALE_MASS + cDENSITY + cAGE_DAYS + DAYS_IN_TREATMENT + EGG_COUNT + HATCHING_SUCCESS + CLUTCH_ORDER + cLENGTH,
              family=gaussian(),
              data = growth2, 
              warmup = 4000, 
              iter = 10000,
              seed=123, 
              cores=2, 
              save_pars = save_pars(all=TRUE),  
              chains = 4, 
              thin = 5, 
              refresh = 0) 
prior_summary(model.mat) 
```
In this summary statistic table it tells us: 

* for the intercept, it is using a student t(flatter normal) prior with a mean of -0.1 and a standard deviation of 2.5. These values are derived from the median and median absolute deviation of the response variable. 


```{r fit-model-2-3}
standist::visualize("student_t(3,-0.1,2.5)", xlim=c(-10,10))
standist::visualize("student_t(3,-0.1,2.5)", xlim=c(-10,10))
```

* for the beta coefficients, including **cDENSITY**, **cFEMALE_STANDARD_LENGTH**, **DEV_TEMP**, the default priors are inproper flat priors. 

* The prior on sigma is also a student t with a mean of **0** and a standard deviation of **3.8** 

### MCMC sampling diagnostics {.tabset} 

#### bayesplot 

```{r mcmc-diag-model2-1, fig.height=9}
mcmc_plot(model.mat, type='combo')
mcmc_plot(model.mat, type='trace') 
mcmc_plot(model.mat, type='dens_overlay') 
mcmc_plot(model.mat, type='acf_bar')
mcmc_plot(model.mat, type='rhat_hist')
mcmc_plot(model.mat, type='neff_hist') 
```

#### stan plots
```{r mcmc-diag-model2-2, fig.height=9}
stan_trace(model.mat$fit)
stan_ac(model.mat$fit) 
stan_rhat(model.mat$fit) 
stan_ess(model.mat$fit)
stan_dens(model.mat$fit, separate_chains = TRUE)
```

### {-}

### Summary 

```{r summary-2}
summary(model.mat)
```

Based on the **model.mat** output **cFEMALE_MASS**,**cAGE_DAYS**, **DAYS_IN_TREATMENT**, and **EGG_COUNT** have no credible influence on **cMASS**. Interestingly, **HATCHING SUCCESS** seems to have a large influence on **cMASS**. 

## Geographic model 

```{r fit-model-3, cache=TRUE}
model.geo <- brm(cMASS ~ DEV_TEMP*REGION + cFEMALE_MASS + cDENSITY + cAGE_DAYS + FEMALE_LAT + cLENGTH,
              family=gaussian(),
              data = growth2, 
              warmup = 4000, 
              iter = 10000,
              seed=123, 
              cores=2, 
              save_pars = save_pars(all=TRUE),  
              chains = 4, 
              thin = 5) 
prior_summary(model.geo) 
```
In this summary statistic table it tells us: 

* for the intercept, it is using a student t(flatter normal) prior with a mean of 0.1 and a standard deviation of 3.8. These values are derived from the median and median absolute deviation of the response variable 

```{r fit-model3-3}
standist::visualize("student_t(3,-0.1,2.5)", xlim=c(-10,10))
standist::visualize("student_t(3,-0.1,2.5)", xlim=c(-10,10))
```

### MCMC sampling diagnostics {.tabset} 

#### bayesplot 

```{r mcmc-diag-model3-1, fig.height=9}
mcmc_plot(model.geo, type='combo')
mcmc_plot(model.geo, type='trace') 
mcmc_plot(model.geo, type='dens_overlay') 
mcmc_plot(model.geo, type='acf_bar')
mcmc_plot(model.geo, type='rhat_hist')
mcmc_plot(model.geo, type='neff_hist') 
```

#### stan plots
```{r mcmc-diag-model3-2, fig.height=9}
stan_trace(model.geo$fit)
stan_ac(model.geo$fit) 
stan_rhat(model.geo$fit) 
stan_ess(model.geo$fit)
stan_dens(model.geo$fit, separate_chains = TRUE)
```

### {-}

### Summary 

```{r summary-3}
summary(model.geo)
``` 
In the geographic model **cFEMALE_MASS**, and **cAGE** have no credible influence while.


# Model Comparisons 

All of our models performed relatively well. To determine which model we will use going forward we will compare the three models we ran against each other. Models will be compared via leave-one-out cross-validation, widely applicable information criterion (waic), and bayes factor. 

The **model.mat** model will not be included in the comparison because the additional covariates within the model did not seem to explain a suitable amount of varirance in the model, ALSO, because there were more _'NA's_ in the these added covariates the observation sizes within the models were different meaning the models cannot be compared against each other using standard model comparison tools. 

## Comparison methods {.tabset}

### WAIC
```{r model-comparisons-1}
model1.waic <- waic(model1)
model.geo.waic <- waic(model.geo) 
#model.mat.waic <- waic(model.mat)
loo_compare(model1.waic, model.geo.waic) 
```  

### LOO
```{r model-comparisons-2}
LOO(model1, model.geo) 
```

### Bayes facotr
```{r model-comparisons-3}
bayes_factor(model1, model.geo)
```
## {-}

# Model fit
Model comparisons indicate that **model1** outperforms **model.geo**. From examining our models we find that **cFEMALE_MASS** and **cAGE** did not have a strong influence on any of the models, and therefore they will not be included in the final model. However, in the maternal model **HATCHING_SUCCESS** was found to have an influence on **cMASS** so we will add this factor into our final model. 

Additional we will add two random factors into our model including, **(1|LEVEL)** and **(1|FEMALE)**. 

```{r random-factors-1, cache=TRUE}
model1.mass <- brm(cMASS ~ DEV_TEMP*REGION + HATCHING_SUCCESS + cDENSITY + cLENGTH + (1|LEVEL) + (1|FEMALE),
              family=gaussian(link="identity"),
              data = growth2, 
              warmup = 4000, 
              iter = 10000,
              seed=123, 
              cores=2, 
              save_pars = save_pars(all=TRUE),  
              chains = 4, 
              thin = 5, 
              control = list(adapt_delta=0.9))  
summary(model1.mass)

```

There seems to be some small issues. Lets investigate the model to find out more. 

## Model validation

```{r model-invest-1}
#--- distribution check ---#
pp_check(model1.mass, type = 'dens_overlay')

#--- DHARMa checks ---#
growth3 <- growth2 |> 
  drop_na(HATCHING_SUCCESS)
preds <- posterior_predict(model1.mass, ndraws=250, summary=FALSE)
model1.mass.resids <- createDHARMa(simulatedResponse = t(preds), 
                              observedResponse = na.omit(growth3$cMASS), 
                              fittedPredictedResponse = apply(preds, 2, median), 
                              integerResponse = 'student')
plot(model1.mass.resids) ; testDispersion(model1.mass.resids)
```

# Model re-fit
There are a couple issues with the way the residuals are distributed. Lets try to add a log-link into the model and see if that helps. 

```{r random-factors-2, cache=TRUE}
model1.mass.log <- brm(cMASS ~ DEV_TEMP*REGION + HATCHING_SUCCESS + cDENSITY + cLENGTH + (1|LEVEL) + (1|FEMALE),
              family=gaussian(link="log"),
              data = growth2, 
              warmup = 4000, 
              iter = 10000,
              seed=123, 
              cores=2, 
              save_pars = save_pars(all=TRUE),  
              chains = 4, 
              thin = 5, 
              control = list(adapt_delta=0.9))  
summary(model1.mass.log)
```

## Model validation
Lets see if the model has improved 

```{r model-invest-2}
#--- distribution check ---#
pp_check(model1.mass.log, type = 'dens_overlay')

#--- DHARMa checks ---#
growth3 <- growth2 |> 
  drop_na(HATCHING_SUCCESS)
preds <- posterior_predict(model1.mass.log, ndraws=250, summary=FALSE)
model1.mass.log.resids <- createDHARMa(simulatedResponse = t(preds), 
                              observedResponse = na.omit(growth3$cMASS), 
                              fittedPredictedResponse = apply(preds, 2, median), 
                              integerResponse = 'student')
plot(model1.mass.log.resids) ; testDispersion(model1.mass.log.resids)
```

Not really, in fact the log link perhaps makes it worse! Maybe we can try a square-root link, as the square root transformation helps if most values are rather small. 

```{r random-factors-3, cache=TRUE, eval=FALSE, echo=FALSE}
model1.mass.sqrt <- brm(cMASS ~ DEV_TEMP*REGION + HATCHING_SUCCESS + cDENSITY + cLENGTH + (1|LEVEL) + (1|FEMALE),
              family=gaussian(link="sqrt"),
              data = growth2, 
              warmup = 4000, 
              iter = 10000,
              seed=123, 
              cores=2, 
              save_pars = save_pars(all=TRUE),  
              chains = 4, 
              thin = 5, 
              control = list(adapt_delta=0.9))  
summary(model1.mass)
```

Lets see if the model has improved 

```{r model-invest-3, eval=FALSE, echo=FALSE}
#--- distribution check ---#
pp_check(model1.mass.log, type = 'dens_overlay')

#--- DHARMa checks ---#
growth3 <- growth2 |> 
  drop_na(HATCHING_SUCCESS)
preds <- posterior_predict(model1.mass.log, ndraws=250, summary=FALSE)
model1.mass.log.resids <- createDHARMa(simulatedResponse = t(preds), 
                              observedResponse = na.omit(growth3$cMASS), 
                              fittedPredictedResponse = apply(preds, 2, median), 
                              integerResponse = 'student')
plot(model1.mass.log.resids) ; testDispersion(model1.mass.log.resids)
```


# Partial effects plots 

## conditional_effects 

```{r partial-plots-cond-eff-1}
model1.mass |> 
  conditional_effects(spaghetti = TRUE, ndraws=200) 
``` 

# Model investigation {.tabset}

## summary 

```{r summary-100}
summary(model1.mass)
```

## R2 

```{r r-squared}
model1.mass |> bayes_R2(summary = FALSE) |> median_hdci()
```

## tidyMCMC 

```{r tidy}
tidyMCMC(model1.mass, estimate.method='median', conf.int=TRUE, conf.method='HPDinterval')
```

## gather draws 

```{r gather_draws}
#model1.re.wo |> get_variables()
model1.mass |> gather_draws(`b_.*|sigma`, regex =TRUE) |> 
  median_hdci()
``` 

## bayesplot 

```{r bayesplot-1}
model1.mass |> mcmc_plot(type='intervals')
```

## emmeans - pariwise 

```{r emmeans-pairwise}
model1.mass |> emmeans(pairwise ~ REGION*DEV_TEMP, type="response") |> pairs(by="DEV_TEMP") |> summary()
```

## probabilities 
```{r probabilities}
model1.mass |> emmeans(~ REGION | DEV_TEMP, at = list(DEV_TEMP = 31.5, length.out = 10)) |> pairs(type = 'response')

```
# {-}

# summary figure 

```{r summary-figure-1}
var <- get_variables(model1.mass); var
var1 <- get_variables(model1.mass)[c(1:4,8:9)] ; var1 

int_draws_spread <- model1.mass |> spread_draws(!!!syms(var1)) 

int_draws_spread2 <- int_draws_spread |> 
  gather_draws(b_Intercept, b_REGIONleading) |> 
  left_join(int_draws_spread, by = c(".chain",".iteration",".draw"))
  
  
int_draws <- int_draws_spread2 |> 
  mutate(x28.5 = case_when(`.variable` == 'b_Intercept' ~ 
                                 `.value`, 
                               `.variable` != 'b_Intercept' ~ 
                                 `.value` + b_Intercept), 
         
         x30 = case_when(`.variable` == 'b_Intercept' ~ 
                                 `.value` + b_DEV_TEMP30, 
                             `.variable` == 'b_REGIONleading' ~ 
                                 `.value` + b_Intercept + b_DEV_TEMP30 + `b_DEV_TEMP30:REGIONleading`), 
         
         x31.5 = case_when(`.variable` == 'b_Intercept' ~ 
                                 `.value` + b_DEV_TEMP31.5, 
                             `.variable` == 'b_REGIONleading' ~ 
                                 `.value` + b_Intercept + b_DEV_TEMP31.5 + `b_DEV_TEMP31.5:REGIONleading`))
  
int_draws_plotting <- int_draws |> 
  pivot_longer(cols = starts_with("x"), 
               names_to = "DEV_TEMP", 
               values_to = "MASS") |> 
  transmute(LATITUDE = case_when(`.variable` == "b_Intercept" ~ "Low latitude", 
                                 `.variable` == "b_REGIONleading" ~ "High latitude"), 
            DEV_TEMP = case_when(DEV_TEMP == 'x28.5' ~ 'DEV_TEMP_28.5', 
                                 DEV_TEMP == 'x30' ~ 'DEV_TEMP_30', 
                                 DEV_TEMP == 'x31.5' ~ 'DEV_TEMP_31.5'),
            MASS = MASS, 
            LATITUDE_B = LATITUDE, 
            DEV_TEMP_B = DEV_TEMP,
            chain = `.chain`, 
            iteration = `.iteration`, 
            draw_n = `.draw`) |> 
  unite("EXP_GROUP",LATITUDE_B, DEV_TEMP_B,sep="_") |> 
  mutate(EXP_GROUP = as.factor(EXP_GROUP)) |> 
  mutate(EXP_GROUP = factor(EXP_GROUP, levels=c("High latitude_DEV_TEMP_28.5","High latitude_DEV_TEMP_30", "High latitude_DEV_TEMP_31.5",
                                                "Low latitude_DEV_TEMP_28.5","Low latitude_DEV_TEMP_30", "Low latitude_DEV_TEMP_31.5")))


mass.plot <- int_draws_plotting |> 
  ggplot(aes(x=EXP_GROUP, y=MASS)) + 
  geom_hline(yintercept = 0, linetype="dashed", linewidth=1, color="grey58", alpha=0.8) + 
  stat_halfeye(aes(fill = EXP_GROUP, fill_ramp = after_stat(level)), 
               point_interval = mode_hdci, 
               .width = c(.66, .90, .95)) + 
  scale_fill_ramp_discrete(na.translate=FALSE, 
                           labels =c("0.95","0.90","0.66"), 
                           name = "Credible interval") +
  scale_fill_manual(values = c("lightskyblue" ,"dodgerblue2", "dodgerblue4","coral", "red2","firebrick4"))+ 
  scale_y_continuous(limits=c(-0.5,0.5), breaks = seq(-0.5,0.5, .1))+
  ylab("CENTERED MASS (g)") + xlab("EXPERIMENTAL GROUP") +
  scale_x_discrete(labels = c("Low latitude_DEV_TEMP_28.5" = paste0("Low latitude 28.5","\u00B0","C"), 
                              "Low latitude_DEV_TEMP_30" = paste0("Low latitude 30","\u00B0","C"),
                              "Low latitude_DEV_TEMP_31.5" = paste0("Low latitude 31.5","\u00B0","C"), 
                              "High latitude_DEV_TEMP_28.5" = paste0("High latitude 28.5","\u00B0","C"),
                              "High latitude_DEV_TEMP_30" = paste0("High latitude 30","\u00B0","C"),
                              "High latitude_DEV_TEMP_31.5" = paste0("High latitude 31.5","\u00B0","C"))) +
  annotate("text", x=6.8,y=1.4, label = paste0(round(mean(growth3$MASS), 2)," (mm)"), color="grey58") +
  coord_flip() + 
  theme_classic() + 
  guides(fill = "none") + 
  theme(legend.position = c(.88,.86), 
        axis.title.y = element_text(margin = margin(r =0.3, unit = "in"), size = 12), 
        axis.title.x = element_text(margin = margin(t = 0.3, unit="in"), size =12), 
        legend.key = element_rect(color="black", size=1.25)); mass.plot
```